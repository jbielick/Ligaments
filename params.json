{"name":"Ligaments","tagline":"Model-View binding for Backbone.js — Bind your bones.","body":"Backbone Ligaments\r\n===============\r\n\r\nDeclarative data binding between Backbone Models and Views.\r\n\r\nCurrently in beta.\r\n\r\n###About\r\n\r\nBackbone.Ligaments binds DOM Elements to Model Attributes on the `name` attributes or `lg-bind` attribute declaration of elements within the view. \r\n`Model.changedAttributes()` are injected on each attribute change event. Backbone-Ligament is fully dot-path accessor friendly. You can use this with `Backbone.DeepModel`\r\nand have full control over injecting, ingesting and binding nested attributes. Any `change` or `input` event from an element \r\nwith a `name` attribute or `lg-bind` attribute within the bound backbone view instance's element will set the new data to the corresponding bound model attribute \r\nand fire a `change` event. The data will be set at the path indicated in the `name` or `lg-bind` attribute in dot-notation or bracket-notation.\r\n\r\n```html\r\n<input type=\"text\" name=\"user[Profile][name]\">\r\nor\r\n<input type=\"text\" lg-bind=\"user.Profile.name\">\r\n```\r\n\r\nWhen a change event occurs, the ingested data structure will look like this:\r\n\r\n```js\r\n{\r\n  user: {\r\n    Profile: {\r\n      name: 'josh'\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n```html\r\n<input type=\"text\" name=\"photo[categories][0][name] value=\"r/awesome\">\r\n<input type=\"text\" name=\"photo[categories][1][name] value=\"r/mildlyinteresting\">\r\nor \t\r\n<input type=\"text\" lg-bind=\"photo.categories.0.name\" value=\"r/awesome\">\r\n<input type=\"text\" lg-bind=\"photo.categories.1.name\" value=\"r/mildlyinteresting\">\r\n```\r\n\r\nWhen a change event occurs, the ingested data structure will look like this:\r\n\r\n```js\r\n{\r\n  photo: {\r\n    categories: [{\r\n      name: 'r/awesome'\r\n    },{\r\n      name: 'r/mildlyinteresting'\r\n    }]\r\n  }\r\n}\r\n\r\n```\r\n\r\nSuppose you want a a number input that keeps it's data type through its journey from the UI to the server. You can use `cast` option in the `bindings` options like the below example.\r\n\r\nWhen providing a `cast` option for an attribute, simply provide a function to be called or an array like so `[parseInt, 10]` where parseInt is the function to be called, the value of your input will be provided as the first argument and `10` will be provided as the second argument—the radix. You can define as many constant arguments as you'd like by appending them to the array. \r\n\r\n```html \r\nwith an input like so...\r\n<input type=\"text\" lg-bind=\"preciseMeasurement\" value=\"0.006\">\r\nor\r\n<input type=\"number\" step=\"0.001\" lg-bind=\"preciseMeasurement\" value=\"0.006\">\r\n```\r\n\r\nA casting function can be provided in the bindings option for that attribute. It can be a custom, anonymous or native // function.\r\n\r\n```js\r\nvar view     = new MyViewClass(),\r\n    model    = new MyModelClass(),\r\n    ligament = new Backbone.Ligaments({\r\n      model: model,\r\n      view: view,\r\n      bindings: {\r\n        'preciseMeasurement': {\r\n          cast: [parseFloat, 10]\r\n      }\r\n     });\r\n\r\n```\r\n\r\nAnd when the model ingests the value from that input, it will be passed through the cast function to modify it in any way you see fit.\r\n\r\n###Usage:\r\n\r\nInclude the ligaments.js file in your application after backbone.js and before any of your views or models are loaded or required.\r\n\r\nTo create data binding between a view and a model, construct a new Ligaments instance by calling `Backbone.Ligaments(options)` method and pass it a object containing your view, model and other options. Currently, there is no way to ~~divorce~~ unbind the view from the model.\r\n\r\n```js\r\n\tvar viewInstance   = new MyViewClass(),\r\n\t    modelInstance  = new MyModelClass(),\r\n\t    ligament       = new Backbone.Ligaments({model: modelInstance, view: viewInstance});\r\n```\r\n\r\nAll input changes in the view will then be ingested by the model and set to its attributes. \r\nSimilarly the ligament will inject any attributes set on the model programmatically into into the view's bound elements.\r\n\r\n##Features\r\n====================\r\n\r\n###beforeInject callback\r\n\r\nIn the example below, a model attribute might look like an ISO datetime string like `2014-04-25T01:53:36.998Z`. If you wanted this attribute, which is bound to an element in the view, to display this date in a human-friendly fashion, you can use beforeInject to mutate the value before it's injected into the view.\r\n\r\nYou may need to translate, mask or manipulate values before they are injected into the view. If a beforeInject method exists on the view that is bound, it will be called in the context of your view and provided the model and the hash returned by Backbone.Model.changedAttributes() method.\r\n\r\nFor example, if your model attribute createdAt stores a datetime string in an ISO/JSON format, but you'd like for it to display as a readable string in your view, check for the changed attribute createdAt in the changedAttributes argument of beforeInject and simply overwrite the value in the changedAttributes hash.\r\n\r\nDoing so won't affect your model or Backbone's copy of changed and previous attributes, but will provide Ligaments with a translated value to inject into the view.\r\n\r\n```js\r\n\tvar ViewClass = Backbone.View.extend({\r\n\t\tel: '.appointmentItem',\r\n\t\tbeforeInject: function(model, changed) {\r\n\t\t\tif (changed.createdAt) {\r\n\t\t\t\tchanged.createdAt = (new Date(changed.createdAt)).toLocaleString();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n```\r\n\r\n###Selective Bindings\r\n\r\nBy default, Backbone.Ligaments will bind all attributes. If you'd like for Backbone.Ligaments to only bind select attributes between your view and model, add an array of attribute names to the binds property of the options hash if you'd like to only bind certain attributes.\r\n\r\n```js\r\n  new Backbone.Ligaments({\r\n    model: UserModel,\r\n    view: UserView,\r\n    bindings: {\r\n      first_name: {},\r\n      last_name: {},\r\n      phone: {\r\n        cast: function(value) {\r\n          return value.replace('-', '');\r\n        }\r\n      }\r\n\t});\r\n```\r\n\r\n###Compatibility\r\n\r\n`Backbone.Ligaments` has been tested and works with `Backbone.DeepModel`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
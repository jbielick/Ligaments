{"name":"Ligaments","tagline":"Model-View binding for Backbone.js â€” Bind your bones.","body":"Backbone Ligaments\r\n===============\r\n\r\nDeclarative data binding between Backbone Models and Views.\r\n\r\nCurrently in beta.\r\n\r\n###About\r\n\r\nligaments.js binds DOM Elements to Model Attributes on the `name` attributes of elements within the view. \r\n`Model.changedAttributes()` are injected on each change event. Any `change` or `input` event from an element with a `name` attribute or `data-bind` attribute within the bound view will set the new data to the bound model and fire a `change` event. The data will be set at the path indicated in the `name` or `data-bind` attribute in dot-notation or bracket-notation.\r\n\r\n```js\r\n// \tname=\"data[User][Profile][name]\r\n// or \t\r\n//\tdata-bind=\"data.User.Profile.name\"\r\n// \r\n// yields\r\n\r\n{\r\n\tdata: {\r\n\t\tUser: {\r\n\t\t\tProfile: {\r\n\t\t\t\tname: '.val() or .text()'\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n###Usage:\r\n\r\nInclude the ligaments.js file in your application after backbone.js and before any of your views or models are loaded or required.\r\n\r\nTo create data binding between a view and a model, construct a new Ligaments instance by calling `Backbone.Ligaments(options)` method and pass it a object containing your view, model and other options. Currently, there is no way to ~~divorce~~ unbind the view from the model.\r\n\r\n```js\r\n\tvar ViewClass = Backbone.View.extend({el: '.MyView'});\r\n\tvar ModelClass = Backbone.Model.extend();\r\n\tnew Backbone.Ligaments({model: new ModelClass(), view: new ViewClass()});\r\n```\r\n\r\nAll input changes in the view will then be ingested by the model and set to its attributes. Since `{readOnly: true}` wasn't set in the options, Ligaments will default to two-way binding&mdash;that is, any attributes set on the model programmatically will be injected into the view.\r\n\r\n\r\n####Example:\r\n\r\n```js\r\n\tvar ViewClass = Backbone.View.extend({el: '.MyElement'});\r\n\r\n\tvar ModelClass = Backbone.Model.extend();\r\n\r\n\tnew Backbone.Ligaments({model: new ModelClass(), view: new ViewClass()});\r\n```\r\n\r\n##Features\r\n====================\r\n\r\n###beforeInject callback\r\n\r\n`Backbone.View.beforeInject(model, changedAttributes)`\r\n\r\nYou may need to translate, mask or manipulate values before they are injected into the view. If a beforeInject method exists on the view that is bound, it will be called in the context of your view and provided the model and the hash returned by Backbone.Model.changedAttributes() method.\r\n\r\nFor example, if your model attribute createdAt stores a datetime string in an ISO/JSON format, but you'd like for it to display as a readable string in your view, check for the changed attribute createdAt in the changedAttributes argument of beforeInject and simply overwrite the value in the changedAttributes hash.\r\n\r\nDoing so won't affect your model or Backbone's copy of changed and previous attributes, but will provide Ligaments with a translated value to inject into the view.\r\n\r\n```js\r\n\tvar ViewClass = Backbone.View.extend({\r\n\t\tel: '.meta',\r\n\t\tbeforeInject: function(model, changed) {\r\n\t\t\tif (changed.createdAt) {\r\n\t\t\t\tchanged.createdAt = (new Date(changed.createdAt)).toLocaleString();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n```\r\n\r\n###Selective Bindings\r\n\r\nBy default, Backbone.Ligaments will bind all attributes. If you'd like for Backbone.Ligaments to only bind select attributes between your view and model, add an array of attribute names to the binds property of the options hash if you'd like to only bind certain attributes.\r\n\r\n```js\r\n\tnew Backbone.Ligaments({\r\n\t\tmodel: UserModel,\r\n\t\tview: UserView,\r\n\t\tbinds: [\r\n\t\t\t'first_name',\r\n\t\t\t'last_name'\r\n\t\t]\r\n\t});\r\n```\r\n\r\n###Compatibility\r\n\r\n`Backbone.Ligaments` has been tested and works with `Backbone.DeepModel`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}